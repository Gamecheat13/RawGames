/****************************************************************************
 
 _dds.gsc
		
*****************************************************************************/

#include common_scripts\utility;
#include animscripts\utility;
#include maps\_utility;

// ************************************************************************************
/*

level.dds.categories is an indexed array of structs indexed by priority (for now, but might changed to keys):
	name						// name of categories
	alias_name					//
	duration					// default duration of events in this category
	priority_sort				// function to sort events within a category by play priority
	clear_on_action_success		// if we play a sound in this category clear all category events
	probability					// probability whether the line should play
	timeout_reset				// timeout ammount between playing a line within the same categories
	timeout						// current timeout remaining before playing a line from this category again

level.dds.active_events is an array (currently indexed by category name):
level.dds.active_events[category_index][event_index] is the event generated by a notify
	category_name(type)			// name of the category of this event
	ent							// associated ent
	ent_origin					// ent origin (dead/cleaned up ents)
	isAlliesLine				// true if it's an allies (friendly) line
	clear_event_on_prob			// flag to remove the event from active events if probability says not to process the event
	processed					// skips processing the event (again) if we already processed it (dont want to remove the event from
								//		active_events for state->event notifies since the same notify can be added again, e.g., grenades).
								//		these events will be removed when duration time runs out
	attacker					// entity's attacker (if exists)
	duration					// remaining time for duration of this event
	category_alias_name			// category alias name; usually truncated name for shorter alias name
	talker						// entity who spoke the line (for responses)
	talker_origin				// talker's origin (for responses)
	category_response_name		// name of category response (if exists)
	processed					// true if the event has already been processed and/or skipped

	debug fields:
		ent_number				// entity number for display (dead/cleaned up ents)
		talker_number			// talker's entity number (for responses)


TODO:
 cut back on the SoundExists script function calls
	-finding variant count
	-checking if a qualifier alias exists
	-checking if a event override alias exists
if the person speaking dies (and the line gets cut off):
	-a response shouldn't be played or maybe a special line should instead
	-add an 'im dying, ack!' line when/as the previous line get cut off
categories:
	-rpg threat
clean up/update debug
	-switch between allies and axis
	-scrollable categories
remove landmark responses; they should just be a part of threat lines
	-dds_woo_rspns_lm_00
*/
// ************************************************************************************


dds_init()
{
	level.dds = spawnstruct();
	level.dds.heartbeat = 0.25;
	//level.dds.heartbeat = .5;

	level.dds.max_active_events = 6;
	level.dds.variant_limit = 40;
	level.dds.category_backoff_limit = 6;
	level.dds.scripted_line_delay = 2;
	level.dds.response_distance_min = 500;

	level.dds.history = [];
	level.dds.history_count = 15;
	level.dds.history_index = 0;

	level.dds.player_character_name = "mas";
	level.dds.event_override_name = undefined;
	level.dds.event_override_probability = .5;
	level.dds.response_wait = 0.25;
	level.dds.response_wait_axis = 0.25;

	init_dds_countryIDs();
	init_dds_flags();

	init_dds_categories();
	init_dds_categories_axis();

	init_dds_active_events();

	// debug
	/#
	level thread dds_debug();
	#/
}


// *************************************************
// INIT
// *************************************************
init_dds_countryIDs( voice, dds_label )
{
	level.dds.characterID_count = 0;
	level.dds.character_names = [];
	level.dds.character_names["allies"]		= array( "american", "russian", "russian_english", "yemeni", "lapd", "secretservice", "unita" );
	level.dds.character_names["axis"]		= array( "digbat", "american", "russian", "unita", "cuban", "mujahideen", "pdf", "pmc", "isi", "terrorist" );
	//level.dds.character_names["team3"]		= array( "russian", "vietnamese", "cuban", "british", "german" );
	level.dds.character_names["default"]	= ArrayCombine( level.dds.character_names["allies"], level.dds.character_names["axis"], true, false );

	//enum { "american", "russian", "unita", "cuban", "mujahideen", "pdf", "pmc", "isi", "digbat", "yemeni", "terrorist", "lapd", "secretservice" } voice
	level.dds.countryIDs = [];
	add_dds_countryID( "american",			"us",	3 ); //us0-us2
	add_dds_countryID( "russian",			"ru",	3 ); //ru0-ru2
	add_dds_countryID( "unita",				"un",	3 ); //un0-un2
	add_dds_countryID( "cuban",				"cb",	3 ); //cb0-cb2
	add_dds_countryID( "mujahideen",		"mu",	3 ); //mu0-mu2
	add_dds_countryID( "pdf",				"pd",	3 ); //pd0-pd2
	add_dds_countryID( "pmc",				"pm",	3 ); //pm0-pm2
	add_dds_countryID( "isi",				"is",	3 ); //is0-is2
	add_dds_countryID( "digbat",			"db",	3 ); //db0-db2
	add_dds_countryID( "yemeni",			"ym",	3 ); //ym0-ym2
	add_dds_countryID( "terrorist",			"tr",	3 ); //tr0-tr2
	add_dds_countryID( "lapd",				"la",	3 ); //la0-la2
	add_dds_countryID( "secretservice",		"ss",	3 ); //ss0-ss2
}

add_dds_countryID( voice, dds_label, max_voices )
{
	level.dds.countryIDs[voice]	= SpawnStruct();
	level.dds.countryIDs[voice].label = dds_label;
	level.dds.countryIDs[voice].count = 0;
	level.dds.countryIDs[voice].max_voices = max_voices;
}

init_dds_flags()
{
	flag_init( "dds_running_allies" );
	level thread dds_send_team_notify_on_disable( "allies" );

	flag_init( "dds_running_axis" );
	level thread dds_send_team_notify_on_disable( "axis" );
}

init_dds_categories()
{
	// The order of this array, determines the priority of events relative to each other
	// static arrays; categories array don't change in size after they leave this function
	//name, alias_name, duration, rspns_cat_name, clear_category_on_action_success, priority_sort, get_talker_func, distance, probability, timeout_reset, should_squelch
	level.dds.categories = [];

						//name				alias				duration	rspns			clear	priority sort			get talker				dist	prob	timeout	squelch
	//add_dds_category( "react_grenade",		"react_grenade",	1.25,		"grenade_rspns",true,	::dds_sort_ent_dist,	::get_nearest,			3000,	.8,		1.5,	false );
	//add_dds_category( "react_sniper",		"react_sniper",		1.25,		"",				true,	::dds_sort_ent_dist,	::get_nearest,			3000,	.8,		1.5,	false );

	//add_dds_category( "rspns_neg",			"rspns_neg",		1.5,		"",				true,	::dds_sort_ent_dist,	::get_self_ent,			2500,	.7,		4.5,	false );
	//add_dds_category( "thrt_acquired",		"thrt_acquired",	0.5,		"",				true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	.5,		4.5,	false );
	
 	add_dds_category( "kill_confirm",		"kill_confirm",		1,			"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	2500,	.6,		3.5,	false );
	add_dds_category( "headshot",			"kill_confirm",		0.75,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	2500,	.6,		4,		false );
	add_dds_category( "gib",				"gib",				0.75,		"",				true,	::dds_sort_ent_dist,	::get_attacker,			1000,	.7,		5,		false );

	//add_dds_category( "rspns_movement",		"rspns_movement",	0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_self_ent,			4000,	.7,		3.5,	false );
	
	//add_dds_category( "fragout",			"act_fragout",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_self_ent,			4000,	.7,		1.5,	false );
	
	//add_dds_category( "thrt_open",			"thrt_open",		0.5,	"rspns_suppress",	true,	::dds_sort_ent_dist,	::get_self_ent,			2000,	.3,		5,		false );
	//add_dds_category( "thrt_movement",		"thrt_movement",	0.5,		"thrt_rspns",	true,	::dds_sort_ent_dist,	::get_self_ent,			2000,	.3,		8,		false );
	//add_dds_category( "thrt_breaking",		"thrt_breaking",	0.5,		"rspns_lm",		true,	::dds_sort_ent_dist,	::get_nearest,			2000,	.2,		5.5,	false );
	//add_dds_category( "rspns_act",			"rspns_act",		0.5,		"",				true,	::dds_sort_ent_dist,	::get_nearest,			2000,	.8,		4,		false );
	//
	//add_dds_category( "react_cover",		"react_cover",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest,			2000,	.8,		4,		false );

	//add_dds_category( "thrt_clock1",		"thrt_clock1",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock10",		"thrt_clock10",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock10h",		"thrt_clock10h",	0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock11",		"thrt_clock11",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock11h",		"thrt_clock11h",	0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock12",		"thrt_clock12",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock12h",		"thrt_clock12h",	0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock1h",		"thrt_clock1h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock2h",		"thrt_clock2h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock3",		"thrt_clock3",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock3h",		"thrt_clock3h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock4h",		"thrt_clock4h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock5",		"thrt_clock5",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock5h",		"thrt_clock5h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock6",		"thrt_clock6",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock6h",		"thrt_clock6h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock7",		"thrt_clock7",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock7h",		"thrt_clock7h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock8",		"thrt_clock8",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock8h",		"thrt_clock8h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock9",		"thrt_clock9",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock9h",		"thrt_clock9h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock9",		"thrt_clock9",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_clock9h",		"thrt_clock9h",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//
	//add_dds_category( "thrt_dist10",		"thrt_dist10",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_dist20",		"thrt_dist20",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_dist30",		"thrt_dist30",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_dist40",		"thrt_dist40",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );

	//add_dds_category( "thrt_elev20",		"thrt_elev20",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_elev30",		"thrt_elev30",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_elev40",		"thrt_elev40",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "thrt_elev50",		"thrt_elev50",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );

	//add_dds_category( "rspns_suppress",		"react_suppress",	0.5,		"",				true,	::dds_sort_ent_dist,	::get_nearest,			2000,	.8,		4,		false );

	//add_dds_category( "low_health",			"health_low",		1.0,		"",				true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.8,		4,		true );
	//add_dds_category( "thrt",				"thrt_spot",		0.5,		"rspns_act",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category( "rspns_lm",			"rspns_lm",			0.5,		"",				true,	::dds_sort_ent_dist,	::get_nearest,			5000,	.7,		3.5,	true );
	add_dds_category( "multikill",			"kill_confirm",		1.5,		"kill_rspns",	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	1,		3.5,	true );

	//kill_rspns  action_rspns
	add_dds_category( "kill_rspns",			"rspns_killfirm",	2,			"",				true,	::dds_sort_ent_dist,	::get_nearest,			5000,	.7,		3.6,	true );
	
	add_dds_category( "kill_explo",			"kill_confirm",		1,			"rspns_act",	true,	::dds_sort_ent_dist,	::get_attacker,			1000,	1,		5,		false );

	add_dds_category( "casualty",			"react_casualty",	0.75,		"",				true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	2800,	.9,		4,		false );
	//add_dds_category( "reload",				"act_reload",		2,			"action_rspns",	true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	.4,		3.5,	false );


	//add_dds_category( "smokeout",			"act_smokeout",		1.25,		"action_rspns",	true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	1,		4,		false );

	add_dds_category( "friendly_fire",		"react_frndlyfire",	1.25,		"",			true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	.9,		4,		true );
	add_dds_category( "civ_fire",			"react_frndlyfire",	1,			"",			true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.9,		4,		true );
	add_dds_category( "kill_melee",			"kill_melee",		0.75,		"",				true,	::dds_sort_ent_dist,	::get_attacker,			400,	1,		3.5,	false );

	// response categories: response to category
	add_dds_category( "grenade_rspns",		"rspns_grenadeexp",	1.25,		"",				true,	::dds_sort_ent_dist,	::get_nearest,			5000,	.7,	0.5,	true );
	add_dds_category( "explode_rspns",	"rspns_kill_exp",	.75,		"",				true,	::dds_sort_ent_dist,	::get_nearest,			1000,	.7,	1,		false );
	add_dds_category( "kill_dmg_shot",	"kill_dmg_shot",	1,		"",				true,	::dds_sort_ent_dist,	::get_attacker,			1000,	1,	3,		false );
	add_dds_category( "kill_dmg_melee",	"kill_dmg_melee",	1,		"",				true,	::dds_sort_ent_dist,	::get_attacker,			1000,	1,	3,		false );
	add_dds_category( "killstreak",			"kllstrk",			.75,	"",				true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	1000,	.8,	2,	true );

	// responses - unused
	//add_dds_category( "reload_rspns",		"rspns_reload",		.5,		false,	true,	::dds_sort_ent_dist,	::get_nearest,			800,	.7,		2,	false );
	//add_dds_category( "fragout_rspns",		"rspns_fragout",	.25,	false,	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	600,	.8,		2,	false );
	//add_dds_category( "headshot_rspns",		"rspns_hs",			.5,		false,	true,	::dds_sort_ent_dist,	::get_nearest,			1000,	.6,		2,	false );
	//add_dds_category( "kill_confirm_rspns",	"rspns_killfirm",	1,		false,	true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	1000,	.7,		3,	false );	
	//add_dds_category( "kill_melee_rspns",	"rspns_kill_melee",	.5,		false,	true,	::dds_sort_ent_dist,	::get_nearest,			400,	.8,		2,	false );	
	//add_dds_category( "kill_explo_rspns",	"rspns_kill_explo",	1,		false,	true,	::dds_sort_ent_dist,	::get_nearest,			1000,	.8,		2,	false );
	//add_dds_category( "killstreak_rspns",	"rspns_killstrk",	1,		false,	true,	::dds_sort_ent_dist,	::get_nearest,			1000,	1,		2,	false );
	//add_dds_category( "gib_rspns",			"rspns_gib",		1,		false,	true,	::dds_sort_ent_dist,	::get_nearest,			1000,	1,		2,	false );
	//add_dds_category( "multikill_rspns",	"rspns_multkill",	1,		false,	true,	::dds_sort_ent_dist,	::get_nearest,			1000,	1,		2,	false );

	//// not set up yet
	//add_dds_category( "kill_uncon",			"kill_uncon",		1,		true,	::dds_sort_ent_dist,	::get_attacker,			1000,	1,		2,	false );
	//add_dds_category( "kill_uncon_rspns",	"rspns_kill_uncon",	1,		true,	::dds_sort_ent_dist,	::get_nearest,			1000,	1,		2,	false );
	//add_dds_category( "moveout",			"moveeout",			1,		true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	1000,	1,		2,	false );
	//add_dds_category( "moveout_rspns",		"rspns_moveeout",	1,		true,	::dds_sort_ent_dist,	::get_nearest,			1000,	1,		2,	false );

	//// unused
	//add_dds_category( "suppressed",			"infrm_spprssd",	1,		false,	::dds_sort_ent_dist,	::get_self_ent,			1000,	0.5,	2,	false );
	//add_dds_category( "ammo_low",			"ammo_low",			1,		false,	::dds_sort_ent_dist,	::get_self_ent,			1000,	1,		2,	false );
}

init_dds_categories_axis()
{
	// The order of this array, determines the priority of events relative to each other
	// static arrays; categories array don't change in size after they leave this function
	level.dds.categories_axis = [];


							//name				alias				duration	rspns				clear	priority sort			get talker				dist	prob	timeout	squelch
	//add_dds_category_axis( "react_grenade",		"react_grenade",	1.25,		"grenade_rspns",	true,	::dds_sort_ent_dist,	::get_nearest,			3000,	.8,		1.5,	false );
	//add_dds_category_axis( "react_sniper",		"react_sniper",		1.25,		"",					true,	::dds_sort_ent_dist,	::get_nearest,			3000,	.8,		1.5,	false );

	//add_dds_category_axis( "rspns_neg",			"rspns_neg",		1.5,		"",					true,	::dds_sort_ent_dist,	::get_self_ent,			2500,	.7,		4.5,	false );
	//add_dds_category_axis( "thrt_acquired",		"thrt_acquired",	0.5,		"",					true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	.5,		6.5,	false );
	
 	add_dds_category_axis( "kill_confirm",		"kill_confirm",		2,			"rspns_act",		true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	2500,	.6,		6.5,	false );
	add_dds_category_axis( "headshot",			"kill_confirm",		0.75,		"rspns_act",		true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	2500,	1,		7,		false );
	add_dds_category_axis( "gib",				"gib",				0.75,		"",					true,	::dds_sort_ent_dist,	::get_attacker,			1000,	.7,		8,		false );


	//add_dds_category_axis( "rspns_movement",	"rspns_movement",	0.5,		"rspns_act",		true,	::dds_sort_ent_dist,	::get_self_ent,			4000,	.7,		3.5,	false );
	
	//add_dds_category_axis( "fragout",			"act_fragout",		0.5,		"rspns_act",		true,	::dds_sort_ent_dist,	::get_self_ent,			4000,	.7,		1.5,	false );
	
	//add_dds_category_axis( "thrt_open",			"thrt_open",		0.5,		"rspns_suppress",	true,	::dds_sort_ent_dist,	::get_self_ent,			2000,	.3,		8,		false );
	//add_dds_category_axis( "thrt_movement",		"thrt_movement",	0.5,		"thrt_rspns",		true,	::dds_sort_ent_dist,	::get_self_ent,			2000,	.3,		8,		false );
	//add_dds_category_axis( "thrt_breaking",		"thrt_breaking",	0.5,		"rspns_lm",			true,	::dds_sort_ent_dist,	::get_nearest,			2000,	.3,		7.5,	false );
	//add_dds_category_axis( "rspns_act",			"rspns_act",		0.5,		"",					true,	::dds_sort_ent_dist,	::get_nearest,			2000,	.8,		4,		false );

	//add_dds_category_axis( "rspns_suppress",	"react_suppress",	0.5,		"",					true,	::dds_sort_ent_dist,	::get_nearest,			2000,	.8,		14,		false );

	
	//add_dds_category_axis( "low_health",		"health_low",		1.0,		"",					true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.8,		4,		true );
	//add_dds_category_axis( "thrt",				"thrt_spot",		0.5,		"rspns_act",		true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.2,  	5,		true );
	//add_dds_category_axis( "rspns_lm",			"rspns_lm",			0.5,		"",					true,	::dds_sort_ent_dist,	::get_nearest,			5000,	.7,		3.5,	true );
	add_dds_category_axis( "multikill",			"kill_confirm",		1.5,		"kill_rspns",		true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	1,		3.5,	true );

//kill_rspns  action_rspns
	add_dds_category_axis( "kill_rspns",		"rspns_killfirm",	2,			"",					true,	::dds_sort_ent_dist,	::get_nearest,			5000,	.7,		3.6,	true );
	
	add_dds_category_axis( "kill_explo",		"kill_confirm",		1,			"rspns_act",		true,	::dds_sort_ent_dist,	::get_attacker,			1000,	1,		5,		false );

	add_dds_category_axis( "casualty",			"react_casualty",	0.75,		"",					true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	2800,	.9,		4,		false );
	//add_dds_category_axis( "reload",			"act_reload",		2,			"action_rspns",		true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	.3,		3.5,	false );


	//add_dds_category_axis( "smokeout",			"act_smokeout",		1.25,		"action_rspns",		true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	1,		4,		false );

	//add_dds_category_axis( "friendly_fire",		"react_frndlyfire",	1.25,		"",					true,	::dds_sort_ent_dist,	::get_self_ent,			5000,	.9,		4,		true );
	//add_dds_category_axis( "civ_fire",			"react_frndlyfire",	1,			"",					true,	::dds_sort_ent_dist,	::get_nearest_not_plr,	5000,	.9,		4,		true );
	add_dds_category_axis( "kill_melee",		"kill_melee",		0.75,		"",					true,	::dds_sort_ent_dist,	::get_attacker,			400,	1,		3.5,	false );
	
	// response categories: response to category

	add_dds_category_axis( "grenade_rspns",		"rspns_grenadeexp",1.25,		"",					true,	::dds_sort_ent_dist,	::get_nearest,			5000,	.7,		0.5,	true );
	add_dds_category( "explode_rspns",	"rspns_kill_exp",	.75,		"",				true,	::dds_sort_ent_dist,	::get_nearest,			1000,	.7,	1,		false );
}


add_dds_category( name, alias_name, duration, rspns_cat_name, clear_category_on_action_success, priority_sort, get_talker_func, distance, probability, timeout_reset, should_squelch )
{
	new_category = spawnStruct();
	new_category.name = name;
	new_category.alias_name = alias_name;
	new_category.duration = duration;
	new_category.priority_sort = priority_sort;
	new_category.probability = probability;
	new_category.get_talker_func = get_talker_func;
	new_category.speaker_distance = distance;
	new_category.last_time = GetTime();
	new_category.backoff_count = 0;
	new_category.timeout = randomInt( 10 );
	new_category.last_timeout = new_category.timeout;
	new_category.timeout_reset = timeout_reset;
	new_category.rspns_cat_name = rspns_cat_name;
	new_category.clear_on_action_success = clear_category_on_action_success;
	new_category.should_squelch = should_squelch;

	level.dds.categories[level.dds.categories.size] = new_category;
}

add_dds_category_axis( name, alias_name, duration, rspns_cat_name, clear_category_on_action_success, priority_sort, get_talker_func, distance, probability, timeout_reset, notused )
{
	new_category_axis = spawnStruct();
	new_category_axis.name = name;
	new_category_axis.alias_name = alias_name;
	new_category_axis.duration = duration;
	new_category_axis.priority_sort = priority_sort;
	new_category_axis.probability = probability;
	new_category_axis.get_talker_func = get_talker_func;
	new_category_axis.speaker_distance = distance;
	new_category_axis.last_time = GetTime();
	new_category_axis.backoff_count = 0;
	new_category_axis.timeout = randomInt( 10 );
	new_category_axis.last_timeout = new_category_axis.timeout;
	new_category_axis.timeout_reset = timeout_reset;
	new_category_axis.rspns_cat_name = rspns_cat_name;
	new_category_axis.clear_on_action_success = clear_category_on_action_success;

	level.dds.categories_axis[level.dds.categories_axis.size] = new_category_axis;
}


init_dds_active_events()
{
	level.dds.active_events = [];
	level.dds.active_events_axis = [];
	
	for( i = 0; i < level.dds.categories.size; i++ )
	{
		level.dds.active_events[level.dds.categories[i].name] = [];
	}

	for( i = 0; i < level.dds.categories_axis.size; i++ )
	{
		level.dds.active_events_axis[level.dds.categories_axis[i].name] = [];
	}
}


// (twice for the two global level threads)
dds_clear_old_expired_events()
{
	for( i = 0; i < level.dds.categories.size; i ++)
	{
		category = level.dds.categories[i];
		for( j = 0; j < level.dds.active_events[category.name].size; j++ )
		{
			level.dds.active_events[category.name][j].duration -= level.dds.heartbeat;
			if( level.dds.active_events[category.name][j].duration <= 0 ||
				level.dds.active_events[category.name][j].clear_event_on_prob )
			{
				// remove this event from the category list
				ArrayRemoveValue( level.dds.active_events[category.name], level.dds.active_events[category.name][j] );
			}
		}
	}
}

dds_clear_old_expired_events_axis()
{
	for( i = 0; i < level.dds.categories_axis.size; i ++)
	{
		category = level.dds.categories_axis[i];
		for( j = 0; j < level.dds.active_events_axis[category.name].size; j++ )
		{
			level.dds.active_events_axis[category.name][j].duration -= level.dds.heartbeat;
			if( level.dds.active_events_axis[category.name][j].duration <= 0 ||
				level.dds.active_events_axis[category.name][j].clear_event_on_prob )
			{
				// remove this event from the category list
				ArrayRemoveValue( level.dds.active_events_axis[category.name], level.dds.active_events_axis[category.name][j] );
			}
		}
	}
}


dds_clear_all_queued_events()
{
	for( i = 0; i < level.dds.categories.size; i ++)
	{
		for( j = 0; j < level.dds.active_events[level.dds.categories[i].name].size; j++ )
		{
			level.dds.active_events[level.dds.categories[i].name] = [];
		}
	}
}

dds_clear_all_queued_events_axis()
{
	for( i = 0; i < level.dds.categories_axis.size; i ++)
	{
		for( j = 0; j < level.dds.active_events_axis[level.dds.categories_axis[i].name].size; j++ )
		{
			level.dds.active_events_axis[level.dds.categories_axis[i].name] = [];
		}
	}
}


dds_main_process() //level thread
{
	if( flag( "dds_running_allies" ) )
		return;

	flag_set( "dds_running_allies" );

	dds_find_threats( "allies", "axis" );
	should_delay_dds = false;

	while( flag( "dds_running_allies" ) )
	{
		dds_clear_old_expired_events();

		if( IsDefined( level.NumberOfImportantPeopleTalking ) && level.NumberOfImportantPeopleTalking > 0 )
		{
			should_delay_dds = true;
			wait( level.dds.heartbeat );

			continue;
		}

		if( should_delay_dds )
		{
			wait( level.dds.scripted_line_delay );
			dds_clear_all_queued_events();
			should_delay_dds = false;
		}

		if( !dds_process_active_events() )
		{
			wait( level.dds.heartbeat );
		}
		else
		{
			wait( 0.1 );
		}
	}
}

dds_main_process_axis() //level thread
{
	if( flag( "dds_running_axis" ) )
		return;

	flag_set( "dds_running_axis" );

	dds_find_threats( "axis", "allies" );
	should_delay_dds = false;

	while( flag( "dds_running_axis" ) )
	{
		dds_clear_old_expired_events_axis();

		if( IsDefined( level.NumberOfImportantPeopleTalking ) && level.NumberOfImportantPeopleTalking > 0 )
		{
			should_delay_dds = true;
			wait( level.dds.heartbeat );

			continue;
		}

		if( should_delay_dds )
		{
			wait( level.dds.scripted_line_delay );
			dds_clear_all_queued_events_axis();
			should_delay_dds = false;
		}

		if( dds_process_active_events_axis() )
		{
			wait( level.dds.heartbeat );
		}
		else
		{
			wait( 0.1 );
		}
	}
}


dds_find_threats( us, them )
{
	level thread dds_find_infantry_threat( us, them );
	//level thread dds_try_suppressed( us );
}

dds_enable( team )
{
	if( !IsDefined( team ) )
	{
		level thread dds_main_process();
		level thread dds_main_process_axis();
	}
	else
	{
		if( team == "allies" )
		{
			level thread dds_main_process();
		}
		else if( team == "axis" )
		{
			level thread dds_main_process_axis();
		}
	}
}

dds_disable( team )
{
	//might need to wait till all the lines are done playing
	if( !IsDefined( team ) )
	{
		dds_clear_all_queued_events();
		flag_clear( "dds_running_allies" );

		dds_clear_all_queued_events_axis();
		flag_clear( "dds_running_axis" );
	}
	else
	{
		switch( team )
		{
		case "axis":
			dds_clear_all_queued_events_axis();
			flag_clear( "dds_running_axis" );
			break;
		case "allies":
			dds_clear_all_queued_events();
			flag_clear( "dds_running_allies" );
			break;
		default:
			/# printLn( "unknown team: " + team + " to disable dds." ); #/
				break;
		}
	}
}

dds_send_team_notify_on_disable( team ) //self == level
{
	while( 1 )
	{
		flag_waitopen( "dds_running_" + team );
		level notify( "dds_running_" + team );
		flag_wait( "dds_running_" + team );
	}
}

is_dds_enabled()
{
	if( level.createFX_enabled || (!flag( "dds_running_allies" ) && !flag( "dds_running_axis" )) )
	{
		return false;
	}
	return true;
}

// *************************************************
// PROCESS
// (twice due to the 2 global active_event threads)
// *************************************************
exponent( base, power )
{
	assert( power >= 0 );

	if( power == 0 )
		return 1;

	return base * exponent( base, ( power - 1 ) );
}

dds_process_active_events()
{
	for( i = 0; i < level.dds.categories.size; i ++ )
	{
		category = level.dds.categories[i];

		/#
		// debug ======
		debug_update_timeouts( category.name, category.timeout, category.last_timeout, true );
		#/

		if( category.timeout > 0 )
		{
			category.timeout -= level.dds.heartbeat;
			continue;
		}

		if( level.dds.active_events[category.name].size != 0 )
		{
			level.dds.active_events[category.name] = [[category.priority_sort]] ( level.dds.active_events[category.name] );
			for( j = 0; j < level.dds.active_events[category.name].size; j ++ )
			{
				if( randomFloat( 1 ) >= category.probability )
				{
					/#
					// debug ======
					debug_active_event_stat( category.name, "probability_skipped", true );
					#/

					level.dds.active_events[category.name][j].clear_event_on_prob = true;
					continue;
				}

				if( level.dds.active_events[category.name][j].processed )
				{
					// for grenades
					//iprintbold( "this event has already been proccessed" );
					continue;
				}

				if( dds_event_activate( level.dds.active_events[category.name][j], category.get_talker_func, category.speaker_distance, 
					category.rspns_cat_name, category.should_squelch ) )
				{
					if( !category.timeout_reset )
					{
						category.timeout = category.timeout_reset;
					}
					else
					{
						if( ( GetTime() - category.last_time ) < ( category.last_timeout * 1.5 * 1000 )  )
						{
							category.backoff_count++;
							if( category.backoff_count > level.dds.category_backoff_limit )
							{
								category.backoff_count = level.dds.category_backoff_limit;
							}
						}
						else
						{
							category.backoff_count--;
							if( category.backoff_count < 0 )
							{
								category.backoff_count = 0;
							}
						}

						//random_num = randomInt( 2 );
						//penalty = category.timeout_reset * ( exponent( 2, category.backoff_count ) ) + random_num;
						category.timeout = category.timeout_reset * ( exponent( 2, category.backoff_count ) ) + randomInt( 2 );
						category.last_timeout = category.timeout;
						category.last_time = GetTime();

						/#
						// debug ======
						debug_reset_timeouts( category.name, category.timeout, category.last_timeout, category.last_time, true );
						#/
					}

					/#
					// debug ======
					debug_sphere_draw_type( "process", category.name, level.dds.active_events[category.name][j], undefined );
					#/

					if( category.clear_on_action_success )
					{
						level.dds.active_events[category.name] = [];
					}
					//maybe add a wait?
					return true;// one line of dialouge per heartbeat?
				}
				else
				{
					wait( level.dds.heartbeat );
				}
			}
		}
	}

	return false;
}
dds_process_active_events_axis()
{
	for( i = 0; i < level.dds.categories_axis.size; i ++ )
	{
		category = level.dds.categories_axis[i];

		/#
		// debug ======
		debug_update_timeouts( category.name, category.timeout, category.last_timeout, false );
		#/

		if( category.timeout > 0 )
		{
			category.timeout -= level.dds.heartbeat;
			continue;
		}

		if( level.dds.active_events_axis[category.name].size != 0 )
		{
			level.dds.active_events_axis[category.name] = [[category.priority_sort]] ( level.dds.active_events_axis[category.name] );
			for( j = 0; j < level.dds.active_events_axis[category.name].size; j ++ )
			{
				if( randomFloat( 1 ) >= category.probability )
				{
					/#
					// debug ======
					debug_active_event_stat( category.name, "probability_skipped", false );
					#/
					level.dds.active_events_axis[category.name][j].clear_event_on_prob = true;
					continue;
				}

				if( level.dds.active_events_axis[category.name][j].processed )
				{
					// for grenades
					//iprintbold( "this event has already been proccessed" );
					continue;
				}

				if( dds_event_activate( level.dds.active_events_axis[category.name][j], category.get_talker_func, category.speaker_distance, 
					category.rspns_cat_name, false ) )
				{
					if( !category.timeout_reset )
					{
						category.timeout = category.timeout_reset;
					}
					else
					{
						if( ( GetTime() - category.last_time ) < ( category.last_timeout * 1.5 * 1000 )  )
						{
							category.backoff_count++;
							if( category.backoff_count > level.dds.category_backoff_limit )
							{
								category.backoff_count = level.dds.category_backoff_limit;
							}
						}
						else
						{
							category.backoff_count--;
							if( category.backoff_count < 0 )
							{
								category.backoff_count = 0;
							}
						}

						//random_num = randomInt( 2 );
						//penalty = category.timeout_reset * ( exponent( 2, category.backoff_count ) ) + random_num;
						category.timeout = category.timeout_reset * ( exponent( 2, category.backoff_count ) ) + randomInt( 2 );
						category.last_timeout = category.timeout;
						category.last_time = GetTime();

						/#
						// debug ======
						debug_reset_timeouts( category.name, category.timeout, category.last_timeout, category.last_time, false );
						#/
					}

					/#
					// debug ======
					debug_sphere_draw_type( "process", category.name, level.dds.active_events_axis[category.name][j], undefined );
					#/

					if( category.clear_on_action_success )
					{
						level.dds.active_events_axis[category.name] = [];
					}
					return true;// one line of dialouge per heartbeat?
				}
				else
				{
					wait( level.dds.heartbeat );
				}
			}
		}
	}

	return false;
}


// check (no other speaking dialogue) and play
dds_event_activate( event, get_talker_func, distance, rspns_cat_name, should_squelch )
{
	if( !IsDefined( event ) )
	{
		/# iPrintLnBold( "event not defined\n" ); #/
		return false;
	}

	category_name = event.category_name;
	if( IsDefined( event.category_response_name ) )
	{
		category_name = event.category_response_name;
	}

	talker = event [[get_talker_func]] ( IsDefined( event.category_response_name ), distance );

	if( !IsDefined( talker ) || !isAlive( talker ) )
	{
		// debug ======
		/#
		//iPrintLnBold( "talker not defined; no one to say dialouge\n" );
		debug_active_event_stat( category_name, "no_one_to_talk_count", event.isAlliesLine );
		#/
		event.processed = true;
		return false;
	}

	phrase = dds_get_alias_from_event( talker, event.category_alias_name, event.ent );
	if( !IsDefined( phrase ) )
	{
		//printLn( "did not find an alias to play. did you set the character for the player?" );
		return false;
	}

	// category response delay
	if( IsDefined( event.category_response_name ) )
	{
		if( event.isAlliesLine )
		{
			wait( level.dds.response_wait );
		}
		else
		{
			wait( level.dds.response_wait_axis );
		}
	}
	
	// PLAY DDS LINE
	// debug ======
	/#
	print_dds = GetDvarIntDefault( "dds_usingDebug", 0 );
	if( IsDefined( print_dds ) && ( print_dds == 1 ) )
	{
		talker thread debug_print_dialogue( phrase );
	}

	debug_active_event_stat( category_name, "processed_count", event.isAlliesLine );
	debug_sphere_draw_type( "speaker", category_name, event, talker );
	#/

	if(!GetDvarint("snd_dsp_futz"))
	{
		should_squelch = false;
	}
	
	if( IsAlive( talker ) )
	{
		if( should_squelch && !IsPlayer( talker ) && ( talker.voice != "russian_english" ) )
		{
			talker animscripts\face::PlayFaceThread( undefined, "dds_squelch_strt", .5, "dds_squelch_strt" );
		}
		
		talker animscripts\face::PlayFaceThread( undefined, phrase, .5, phrase );
	}

	if( should_squelch && !IsPlayer( talker ) && IsAlive( talker ) && ( talker.voice != "russian_english" ) )
	{
		talker animscripts\face::PlayFaceThread( undefined, "dds_squelch_end", .5, "dds_squelch_end" );
	}

	event.talker = talker;
	event.talker_origin = talker.origin;
	event.phrase = phrase;
	event.processed = true;

	add_phrase_to_history( phrase );

	if( rspns_cat_name != "" )
	{
		dds_notify_response( event, talker, phrase, rspns_cat_name );
	}

	return true;
}


add_phrase_to_history( phrase )
{
	level.dds.history[level.dds.history_index] = phrase;
	level.dds.history_index = ( level.dds.history_index + 1 ) % level.dds.history_count;
}


// *************************************************
// BUILD ALIAS get_talker_func
// *************************************************
get_nearest_common( response, player_can_say_line, distance ) //self == event
{
	player = get_players()[0];

	if( self.isAlliesLine )
	{
		ai_array = GetAIArray( "allies" );

		if( player_can_say_line )
		{
			ai_array[ai_array.size] = player;
		}
	}
	else
	{
		ai_array = GetAIArray( "axis" );
	}

	if( ai_array.size <= 0 )
		return undefined;

	ai_array = 	remove_all_actors_that_are_squelched( ai_array );
	
	if( response && IsDefined( self.talker ) )
	{
		ai_array = remove_all_actors_with_same_characterID( ai_array, self.talker.dds_characterID );
		closest_ent = get_closest_living( self.talker.origin, ai_array );
	}
	else
	{
		closest_ent = get_closest_living( self.ent_origin, ai_array );
	}

	if( !IsDefined( closest_ent ) )
		return undefined;

	dis_sq_from_player = distancesquared( player.origin, closest_ent.origin );

	if( dis_sq_from_player > distance*distance )
	{
		return undefined;
	}

	if( response && ( dis_sq_from_player < level.dds.response_distance_min*level.dds.response_distance_min ) )
	{
		return undefined;
	}

	return closest_ent;
}

remove_all_actors_that_are_squelched( ai_array )
{
	non_squelched = [];
	foreach (ai in ai_array)
	{
		if (!isDefined(ai.bsc_squelched))
		{
			non_squelched[non_squelched.size] = ai;
		}
	}
	return non_squelched;
}


remove_all_actors_with_same_characterID( ai_array, talker_characterID )
{
	for( i = 0; i < ai_array.size; )
	{
		if( !IsDefined( ai_array[i].dds_characterID ) )
		{
			ArrayRemoveValue( ai_array, ai_array[i] );
			continue;
		}

		if( ai_array[i].dds_characterID == talker_characterID )
		{
			ArrayRemoveValue( ai_array, ai_array[i] );
			continue;
		}
		i++;
	}
	return ai_array;
}


get_nearest( response, distance ) //self == event
{
	return get_nearest_common( response, true, distance );
}


get_nearest_not_plr( response, distance ) //self == event
{
	return get_nearest_common( response, false, distance );
}


get_attacker( response, distance ) //self == event
{
	if( IsDefined( self.ent_attacker ) && IsAlive( self.ent_attacker ) )
	{
		// don't say a line if the AI you attacked was a teammate!
		if( IsDefined( self.ent_team ) ) //for vehicles self.ent_attacker.vteam
		{
			if( IsDefined( self.ent_attacker.team ) && self.ent_team == self.ent_attacker.team )
			{
				return undefined;
			}
			if( IsDefined( self.ent_attacker.vteam ) && self.ent_team == self.ent_attacker.vteam )
			{
				/# PrintLn( "^5 killed by a vehicle" ); #/
				return undefined;
			}
		}
		return self.ent_attacker;
	}

	return undefined;
}


get_self_ent( response, distance ) //self == event
{
	if( IsDefined( self.ent ) && isAlive( self.ent ) )
	{
		return self.ent;
	}
	return undefined;
}


dds_get_alias_from_event( talker, category_alias_name, event_ent )
{
	if( !IsAlive( talker ) )
	{
		/# PrintLn( "talker is dead" ); #/
		return undefined;
	}

	if( !IsDefined( talker.dds_characterID ) )
	{
		/# PrintLn( "character name could not be found for this speaker." ); #/
		return undefined;
	}

	alias = "dds_" + talker.dds_characterID + "_" + category_alias_name + "_";

	if( IsDefined( event_ent ) && category_alias_name == "thrt" )
	{
		qualifier = event_ent get_landmark_qualifier( alias );

		if( IsDefined( qualifier ) )
		{
			alias += qualifier + "_";
		}
	}


	//TEMP; COMMENTED OUT FOR NOW
	//event_override = get_event_override( alias );
	//if( IsDefined( event_override ) )
	//{
	//	alias += event_override + "_";
	//}

	variant_num = 0;
	variant_count_array = dds_variant_count_for_alias( alias );

	if( variant_count_array.size > 0 )
	{
		for( i = 0; i < variant_count_array.size; i++ )
		{
			variant_num = random( variant_count_array );
			temp_alias = alias;

			if( variant_num < 10 )
				temp_alias += "0";

			temp_alias += variant_num;

			if( !is_phrase_in_history( temp_alias ) )
				return temp_alias;
		}
	}
	else
	{
		/#
		missing_dds = GetDvarIntDefault( "dds_usingDebug", 0 );
		if( IsDefined( missing_dds ) && ( missing_dds == 1 ) )
		{
			PrintLn( "^5 did not find an alias: '" + alias + "'" );
		}
		#/

		return undefined;
	}

	/#
	missing_dds = GetDvarIntDefault( "dds_usingDebug", 0 );
	if( IsDefined( missing_dds ) && ( missing_dds == 1 ) )
	{
		PrintLn( "^6all variants for alias: '" + alias + "' are in the phrase history." );
	}
	#/

	return undefined;
}

is_phrase_in_history( phrase )
{
	for( i = 0; i < level.dds.history.size; i++ )
	{
		if( level.dds.history[i] == phrase )
		{
			return true;
			//break;
		}
	}
	return false;
}

dds_variant_count_for_alias( alias )
{
	variant_count_array = [];
	for( i = 0; i < level.dds.variant_limit; i++ )
	{
		prefix = "";
		if( i < 10 )
			prefix = "0";

		if( SoundExists( alias + prefix + i ) )
		{
			variant_count_array[variant_count_array.size] = i;
		}
	}
	return variant_count_array;
}


// might want to move this to where we send the notify
get_landmark_qualifier( alias ) //self == event_ent (the entitiy that caused the event)
{
	lm_script_area = undefined;
	lm_script_area_origin = undefined;

	if( !IsDefined( self.node ) )
	{
		nodeArray = GetAnyNodeArray( self.origin, 100 );
		for( i = 0; (i < nodeArray.size && i < 3); i++ )
		{
			if( IsDefined( nodeArray[i].script_area ) )
			{
				lm_script_area = nodeArray[i].script_area;
				lm_script_area_origin = nodeArray[i].origin;
				break;
			}
		}
	}
	else if( IsDefined( self.node.script_area ) )
	{
		lm_script_area = self.node.script_area;
		lm_script_area_origin = self.node.origin;
	}
	
	if( !IsDefined( lm_script_area ) || !IsDefined( lm_script_area_origin ) )
		return undefined;

	if( ( distancesquared( self.origin, lm_script_area_origin ) < 400*400 ) && SoundExists( alias + lm_script_area + "_00" ) )
	{
		return lm_script_area;
	}
	
	//println( "no alias with qualifier: " + qualifier + " exists. returning undefined 'qualifier'." );
	return undefined;
}


get_event_override( alias )
{
	if( IsDefined( level.dds.event_override_name ) && ( randomFloat( 1 ) >= level.dds.event_override_probability ) && 
		SoundExists( alias + level.dds.event_override_name + "_00" ) )
	{
		return level.dds.event_override_name;
	}

	return undefined;
}


// *************************************************
// STATE BASED EVENTS
// *************************************************
// if we want more landmark lines playing (?) we might have to add more logic here as opposed to where the alias is built
dds_find_infantry_threat( us, them )
{
	const THRT_INF_NOTIFY_DISTANCE = 4000;
	while( flag( "dds_running_" + us ) )
	{
		player = get_players()[0];
		our_team = GetAIArray( us );
		other_team = GetAIArray( them );
		success = false;

		for( i = 0; i < our_team.size; i++ )
		{
			for( j = 0; j < other_team.size; j++ )
			{
				if( ( other_team.size > 1 ) && ( randomFloat( 1 ) < .5 ) )
				{
					if( other_team[j] canSee( our_team[i] ) && ( distancesquared( other_team[j].origin, our_team[i].origin ) < THRT_INF_NOTIFY_DISTANCE*THRT_INF_NOTIFY_DISTANCE ) &&
						( distancesquared( other_team[j].origin, player.origin ) < THRT_INF_NOTIFY_DISTANCE*THRT_INF_NOTIFY_DISTANCE ) )
					{
						//other_team[j] dds_notify( "thrt", ( them != "allies" ) );
						other_team[j] dds_threat_notify (them != "allies");
						success = true;
						break;
					}
				}
			}
			if( success )
				break;
		}

		wait( 2 );
	}
}

dds_getclock_position( pos )
{
	if( !IsDefined( level.player ) )
	{
		return;
	}

	playerAngles = level.player getplayerangles();
	playerForwardVec = AnglesToForward( playerAngles );
	playerUnitForwardVec = VectorNormalize( playerForwardVec );

	playerPos = level.player GetOrigin();
	playerToBanzaiVec = pos - playerPos;
	playerToBanzaiUnitVec = VectorNormalize( playerToBanzaiVec );

	forwardDotBanzai = VectorDot( playerUnitForwardVec, playerToBanzaiUnitVec );

	angleFromCenter = ACos( forwardDotBanzai );

	crossPlayerEnemy = VectorCross(playerUnitForwardVec, playerToBanzaiUnitVec);

	dir = VectorDot( crossPlayerEnemy, AnglesToUp(playerAngles) );

	if ( dir < 0 )
	{
		angleFromCenter = angleFromCenter * (-1);
	}

	a = angleFromCenter + 180;

	hour = 6;
	for(i = 15; i < 375; i += 30)
	{
		if ( a < i )
		{
			break;
		}

		hour = hour - 1;

		if ( (hour) < 1 )
		{
			hour = 12;
		}
	}

	return hour;
}

//checks availible threat types and sends proper notify
dds_threat_notify(isAlliesLine)  // self == AI
{
	if( !IsDefined( level.player ) )
	{
		return;
	}

	// get vertical distance
	aiPos = self.origin;
	playerPos = level.player.origin;

	// get distance
	distance = DistanceSquared( playerPos, aiPos );

	// favor closer enemies
	if( distance < 200 )
	{
		/#println( "(DDS) distance ", distance);#/
		self dds_notify( "thrt_dist10", isAlliesLine );
	}
	else if( distance < 500 )
	{
		/#println( "(DDS) distance ", distance);#/
		self dds_notify( "thrt_dist20", isAlliesLine );

	}
	else if( distance < 1000 )
	{
		/#println( "distance ", distance);#/
		self dds_notify( "thrt_dist30", isAlliesLine );
	}
	else
	{
		oclock = dds_getclock_position(aiPos);
		/#println( "(DDS) enemy at  ", oclock ); #/
		self dds_notify( "thrt_clock" + oclock, isAlliesLine );
	}
}

/*
dds_try_suppressed( us )
{
	level endon( "dds_running_" + us );

	while( 1 )
	{
		our_team = GetAIArray( us );

		for( i = 0; i < our_team.size; i++ )
		{
			if( our_team[i] isSuppressedWrapper() )
			{
				our_team[i] dds_notify( "suppressed", ( us == "allies" ) );
				break;
			}
		}

		wait( 5 );
	}
}
*/


// ***********************************************************
// PLAYER INIT (initially called from load onPlayerSpawned)
// ***********************************************************
player_init() //self == player
{
	if( !IsPlayer( self ) )
	{
		/#PrintLn( "dds::player_init not called on a player; did not set up dds player flags and threads." );#/
		return;
	}

	self.isKillstreakTimerRunning = false;
	self.killstreakcounter = 0;

	//self ent_flag_init( "dds_ammo_low" );
	self ent_flag_init( "dds_killstreak" );
	self ent_flag_init( "dds_low_health" );

	//self thread dds_watch_ammo_low();
	self thread dds_killstreak_timer();
	self thread dds_watch_player_health();
	self thread dds_multikill_tracker();

	self.dds_characterID = level.dds.player_character_name;
}


dds_multikill_tracker() //self == player
{
	self endon( "death" );
	self endon( "disconnect" );

	while( 1 )
	{
		level flag_wait( "dds_running_" + self.team );

		self waittill( "multikill" );
		self dds_notify( "multikill", ( self.team == "allies" ) );
	}
}

/*
//see waittillReloadFinished()
dds_watch_ammo_low() //self == player
{
	self endon( "death" );
	self endon( "disconnect" );

	//might have to have a check for the player being in last stand
	while( 1 )
	{
		level flag_wait( "dds_running_" + self.team );

		wait( 1 );

		weapon = self GetCurrentWeapon();
		if( weapon == "none" )
		{
			continue;
		}

		if( self GetFractionMaxAmmo( weapon ) <= 0.2 )
		{
			self dds_notify( "ammo_low", self.team == "allies" );
			self ent_flag_set( "dds_ammo_low" );
			self thread reset_ammo_low();
		}
		self ent_flag_waitopen( "dds_ammo_low" );
	}
}

reset_ammo_low() //self == player
{
	self endon( "death" );
	self endon( "disconnect" );

	while( 1 )
	{
		weapon = self GetCurrentWeapon();

		if( self GetFractionMaxAmmo( weapon ) > 0.2 )
		{
			self ent_flag_clear( "dds_ammo_low" );
			return;
		}

		wait( 1 );
	}
}
*/


dds_watch_player_health() //self == player
{
	self endon( "death" );
	self endon( "disconnect" );

	//# self thread dds_debug_player_health(); #/
	while( 1 )
	{
		level flag_wait( "dds_running_" + self.team );

		wait( 0.5 );

		if( self.health < self.maxhealth * 0.4 )
		{
			self dds_notify( "low_health",  self.team == "allies" );
			self ent_flag_set( "dds_low_health" );
			self thread reset_player_health();
		}

		self ent_flag_waitopen( "dds_low_health" );
	}
}

reset_player_health()
{
	self endon( "death" );
	self endon( "disconnect" );

	while( 1 )
	{
		if( self.health > self.maxhealth * 0.75 )
		{
			self ent_flag_clear( "dds_low_health" );
			return;
		}

		wait( 1 );
	}
}


dds_killstreak_timer() //self == player
{
	self endon( "death" );
	self endon( "disconnect" );

	kills = GetDvarIntDefault( "dds_killstreak_kills", 3 );
	time = GetDvarIntDefault( "dds_killstreak_timer", 10 );

	while( 1 )
	{
		level flag_wait( "dds_running_" + self.team );

		self ent_flag_wait( "dds_killstreak" );
		self.killstreakcounter++;

		if( !self.isKillstreakTimerRunning )
		{
			self.isKillstreakTimerRunning = true;
			self thread track_kills_over_time( kills, time );
		}
		self ent_flag_clear( "dds_killstreak" );
	}
}

track_kills_over_time( kills, time ) //self == player
{
	timer = GetTime() + ( time * 1000 );
	
	while( GetTime() < timer )
	{
		if( self.killstreakcounter >= kills )
		{
			self dds_notify( "killstreak", self.team == "allies" );

			self.killstreakcounter = 0;
			timer = -1;
		}
		wait( 0.1 );
	}
	self.killstreakcounter = 0;
	self.isKillstreakTimerRunning = false;
}


// ***********************************************************
// AI/ACTOR INIT (called from _spawner.gsc spawn_think_action)
// ***********************************************************
dds_ai_init() //self == AI
{
	self dds_get_ai_id();

	self thread dds_watch_grenade_flee();
	self thread dds_watch_friendly_fire();
}

dds_get_ai_id()
{
	classname = ToLower( self.classname ); //setAnimType() in init.gsc
	tokens = StrTok( classname, "_" );

	if( tokens.size >= 2 )
	{
		switch( tokens[1] ) // first token is 'actor'
		{
			// BLACKLIST
			case "clark":
			case "mason":
			case "carlos":
				return;

			// HEROES
			case "barnes":
				self.dds_characterID = "woo";
				return;
			case "lewis":
				self.dds_characterID = "bow";
				return;

			case "reznov":
			case "woods":
			case "bowman":
			case "weaver":
			case "hudson":
				self.dds_characterID = GetSubStr( tokens[1], 0, 3 ); // "woo", "bow", "mas", "wea", "hud"
				return;
		}
	}

	if( self.team != "neutral" )
	{
		for( i = 0; i < level.dds.character_names[self.team].size; i++ ) //"american", "russian", ...
		{
			if( self.voice == level.dds.character_names[self.team][i] )
			{
				self.dds_characterID = level.dds.countryIDs[self.voice].label + ( level.dds.countryIDs[self.voice].count % level.dds.countryIDs[self.voice].max_voices );
				level.dds.countryIDs[self.voice].count++;
				return;
			}
		}
	}
	else
	{
		//self.dds_characterID = undefined;
		return;
	}

	/#printLn( "dds: didn't set this AI with a dds_characterID" );#/
}


dds_watch_grenade_flee() //self == AI
{
	self endon( "death" );
	self endon( "disconnect" );

	while( 1 )
	{
		self waittill( "grenade_flee", weaponName );

		// Right now, we only want grenades to trigger react_grenade lines.
		if( weaponName == "frag_grenade_sp" )
		{
			self dds_notify( "react_grenade", ( self.team == "allies" ) );
		}
	}
}


dds_watch_friendly_fire() //self == AI that got shot
{
	self endon( "death" );
	self endon( "disconnect" );

	while( 1 )
	{
		self waittill( "dds_friendly_fire" );
		self dds_notify( "friendly_fire", ( self.team == "allies" ) );
	}
}


// *************************************************
// DDS CALLBACK
// *************************************************
update_player_damage( eAttacker ) //self == player
{
	if( !is_dds_enabled() )
	{
		return;
	}

	self.dds_dmg_attacker = eAttacker;
}

update_actor_damage( eAttacker, damage_mod ) //self == AI that took daamge
{
	if( !is_dds_enabled() )
	{
		return;
	}

	// set dmg_attacker field
	self.dds_dmg_attacker = eAttacker;

	if( IsPlayer( eAttacker ) )
	{
		switch( damage_mod )
		{
			case "MOD_GRENADE_SPLASH":
			case "MOD_IMPACT":
				return;
		}

		if( self.team == eAttacker.team )
		{
			self notify( "dds_friendly_fire" );
		}
		else if( self.team == "neutral" )
		{
			self dds_notify( "civ_fire", ( eAttacker.team == "allies" ) );
		}
	}
}


// *************************************************
// DDS FILTER/WRAPPERS
// *************************************************
check_kill_damage( mod, dmg_mod )
{
	//check here for the 'kill_damage_shot/melee' category before the MOD stuff
	if( IsDefined( self.dds_dmg_attacker ) && IsDefined( self.dds_dmg_attacker.dds_dmg_attacker ) )
	{
		if( self == self.dds_dmg_attacker.dds_dmg_attacker )
		{
			return ( "kill_dmg_" + dmg_mod );
		}
	}
	return mod;
}


//add an extra check for when an ent's attacker returns an ent from the same team
dds_notify_mod( isAlliesLine, category_name ) //self == ent calling notify (ent that died)
{
	if( !is_dds_enabled() )
	{
		return;
	}

	//probably came from a ragdoll death that didn't have a MOD
	if( !IsDefined( self.damagemod ) )
		return;

	//if friendly fire or civilian, return
	if( IsDefined( self.dds_dmg_attacker ) && IsDefined( self.team ) )
	{
		if( IsDefined( self.dds_dmg_attacker.team ) && ( ( self.dds_dmg_attacker.team == self.team ) || ( self.team == "neutral" ) ) )
		{
			return;
		}
		else if( IsDefined( self.dds_dmg_attacker.vteam ) && ( self.dds_dmg_attacker.vteam == self.team ) )
		{
			return;
		}
	}

	is_bullet_kill = false;
	//headshots vs melee to the head
	//death by bullet, death by grenade, death by explosion
	if( !IsDefined( category_name ) )
	{
		switch( self.damagemod )
		{
			case "MOD_CRUSH":
			case "MOD_TELEFRAG":
			case "MOD_FALLING":
			case "MOD_SUICIDE":
			case "MOD_TRIGGER_HURT":
			case "MOD_BURNED":
			case "MOD_HIT_BY_OBJECT":
			case "MOD_DROWN":
				//printLn( "^5 MODs to be removed??? ( " + self.damagemod + ") \n" );
				break;
			case "MOD_UNKNOWN":
			case "MOD_PROJECTILE":
			case "MOD_PROJECTILE_SPLASH":
			case "MOD_BAYONET":
				//printLn( "^5 unknown, projectile, projectile_splash, bayonet: " + self.damagemod + " \n" );
				break;
			case "MOD_MELEE":
				self dds_notify( check_kill_damage( "kill_melee", "melee" ), isAlliesLine );
				break;
			case "MOD_EXPLOSIVE":
			case "MOD_GRENADE": // cooked grenades?
			case "MOD_GRENADE_SPLASH":
				self dds_notify( "kill_explo", isAlliesLine );
				//self dds_notify( "grenade_damage", isAlliesLine );
				//printLn( "^5 grenade, grenade_splash: " + self.damagemod + " \n" );
				break;
			case "MOD_PISTOL_BULLET":
			case "MOD_RIFLE_BULLET":
				if( animscripts\combat_utility::isSniperRifle(self.damageWeapon) )
				{
					self dds_notify( check_kill_damage( "react_sniper", "shot" ), !isAlliesLine );
					is_bullet_kill = true;
					break;					
				}
				else
				{
					self dds_notify( check_kill_damage( "kill_confirm", "shot" ), isAlliesLine );
					is_bullet_kill = true;
					break;
				}
			case "MOD_HEAD_SHOT":
				//self dds_notify( "headshot", isAlliesLine );
				//printLn( "^6 headshot (but shouldn't be here): " + self.damagemod + " \n" );
				is_bullet_kill = true;
				break;
			default:
				/#printLn( "^5 MOD: " + self.damagemod + " \n" );#/
				//assertMsg( "no MOD for this death dds notify." );
				break;
		}
	}
	else //headshots...
	{
		self dds_notify( category_name, isAlliesLine );
		is_bullet_kill = true;
	}

	if( IsPlayer( self.attacker ) && is_bullet_kill )
	{
		self.attacker ent_flag_set( "dds_killstreak" );
	}
}


dds_notify_casualty() //self == ent calling notify ( ent that died )
{
	self dds_notify( "casualty", ( self.team == "allies" ) );
}


dds_notify_grenade( grenade_name, isAlliesLine, isThrowBack ) //self == ent throwing grenade
{
	if( !is_dds_enabled() )
	{
		return;
	}

	if( !isThrowBack )
	{
		switch( grenade_name )
		{
			case "frag_grenade_sp":
				self dds_notify( "fragout", isAlliesLine );
				break;
			case "willy_pete_sp":
				self dds_notify( "smokeout", isAlliesLine );
				break;
			case "flash_grenade_sp":
			case "m8_white_smoke_sp": //?
			case "claymore_sp":
			case "molotov_sp":
			case "vc_grenade_sp":
				/# printLn( "dds should we say something about this category grenade type: " + grenade_name + "?" ); #/
				break;
			default:
				/# printLn( "dds do you want to add a category for this grenade type: " + grenade_name + "?" ); #/
				break;
		}
	}
	else //change
	{
		self dds_notify( "frag_throwback", isAlliesLine );
	}
}


dds_notify_reload( weaponName, isAlliesLine ) //self == ent reloading
{
	if( !IsDefined( weaponName ) )
	{
		self dds_notify( "reload", isAlliesLine );
		return;
	}
	else if( ( self GetCurrentWeaponClipAmmo() > 0 ) )
	{
		// partial reload, don't send a notify
		return;
	}

	switch( weaponName )
	{
		// weapons we don't want to trigger reload lines for
		case "crossbow_sp":
		case "crossbow_vzoom_alt_sp":
		case "crossbow_explosive_alt_sp":
			break;
		default:
			self dds_notify( "reload", isAlliesLine );
			break;
	}
}


// *************************************************
// DDS NOTIFY
// *************************************************
dds_notify( category_name, isAlliesLine ) //self == ent calling notify
{
	if( !flag( "dds_running_allies" ) && isAlliesLine )
	{
		return;
	}
	if( !flag( "dds_running_axis" ) && !isAlliesLine )
	{
		return;
	}

	if( isAlliesLine && !IsDefined( level.dds.active_events[category_name] ) )
	{
		return;
	}
	if( !isAlliesLine && !IsDefined( level.dds.active_events_axis[category_name] ) )
	{
		return;
	}

	assert( IsDefined( level.dds ), "dds not init." );
	//assert( IsDefined( level.dds.active_events[category_name] ), "didn't setup " + category_name + " as a category type." );
	//assert( IsDefined( level.dds.active_events_axis[category_name] ), "didn't setup " + category_name + " as a category type." );
	assert( IsDefined( isAlliesLine ), "isAlliesLine is not defined." );

	if( !isAlliesLine )
	{
		if( level.dds.active_events_axis[category_name].size > level.dds.max_active_events )
		{
			return;
		}
	}
	else
	{
		if( level.dds.active_events[category_name].size > level.dds.max_active_events )
		{
			return;
		}
	}
	
	event = spawnstruct();
	event.category_name = category_name;
	event.ent = self;
	event.ent_origin = self.origin; //some ents die...
	event.ent_team = self.team;
	event.clear_event_on_prob = false;
	event.processed = false;
	event.ent_attacker = self.dds_dmg_attacker;
	event.isAlliesLine = isAlliesLine;

	// debug ======
	/#
	event.ent_number = self GetEntityNumber();
	debug_sphere_draw_type( "notify", event.category_name, event, undefined );
	debug_active_event_stat( category_name, "total_notify_count", isAlliesLine );
	#/

	// when to add it to actice_events or active_events_axis
	if( !isAlliesLine )
	{
		dds_category = find_dds_category_by_name( level.dds.categories_axis, category_name );
		if( !IsDefined( dds_category ) )
		{
			return;
		}
		event.duration = dds_category.duration;
		event.category_alias_name = dds_category.alias_name;

		level.dds.active_events_axis[category_name][level.dds.active_events_axis[category_name].size] = event;
	}
	else
	{
		dds_category = find_dds_category_by_name( level.dds.categories, category_name );
		if( !IsDefined( dds_category ) )
		{
			return;
		}
		event.duration = dds_category.duration;
		event.category_alias_name = dds_category.alias_name;

		level.dds.active_events[category_name][level.dds.active_events[category_name].size] = event;
	}
}


dds_notify_response( event, talker, phrase, rspns_cat_name )
{
	event.category_response_name = rspns_cat_name;
	event.processed = false;

	//don't want a friendly response to player thrown grenades
	if( ( rspns_cat_name == "grenade_rspns" ) && IsDefined( event.ent ) && IsDefined( event.ent.grenade ) && IsDefined( event.ent.grenade.originalowner ) &&
		( IsDefined( event.ent.grenade.originalowner.team != event.ent_team ) ) )
		return;

	// debug ======
	/#
	//event.talker_number = talker GetEntityNumber();
	debug_sphere_draw_type( "notify", event.category_response_name, event, undefined );
	debug_active_event_stat( event.category_response_name, "total_notify_count", event.isAlliesLine );
	#/

	if( !event.isAlliesLine )
	{
		dds_category = find_dds_category_by_name( level.dds.categories_axis, event.category_response_name );
		if( !IsDefined( dds_category ) )
		{
			return;
		}
		event.duration = dds_category.duration;
		event.category_alias_name = dds_category.alias_name;

		level.dds.active_events_axis[event.category_response_name][level.dds.active_events_axis[event.category_response_name].size] = event;
	}
	else
	{
		dds_category = find_dds_category_by_name( level.dds.categories, event.category_response_name );
		if( !IsDefined( dds_category ) )
		{
			return;
		}
		event.duration = dds_category.duration;
		event.category_alias_name = dds_category.alias_name;

		level.dds.active_events[event.category_response_name][level.dds.active_events[event.category_response_name].size] = event;
	}
}


find_dds_category_by_name( category_array, category_name )
{
	for( i = 0; i < category_array.size; i++ )
	{
		if( category_array[i].name == category_name )
		{
			return category_array[i];
		}
	}
	// category was not set up
	return undefined;
}


// *************************************************
// SORT FUNCTIONS
// *************************************************
dds_sort_ent_dist( eventArray )
{
	player = get_players()[0];
		
	dist_array = [];
	index_array = [];
	for( i = 0; i < eventArray.size; i++ )
	{
		length = distancesquared( player.origin, eventArray[i].ent_origin );
		dist_array[dist_array.size] = length;
		index_array[index_array.size] = i;
	}

	temp = undefined;
	for( i = 0; i < dist_array.size - 1; i++ )
	{
		if( dist_array[i] <= dist_array[i + 1] )
			continue;
		temp = dist_array[i];
		dist_array[i] = dist_array[i + 1];
		dist_array[i + 1] = temp;
		
		temp = index_array[i];
		index_array[i] = index_array[i + 1];
		index_array[i + 1] = temp;
	}

	new_array = [];
	for( i = 0; i < index_array.size; i++ )
	{
		new_array[i] = eventArray[index_array[i]];
	}

	return new_array;
}


dds_sort_ent_duration( eventArray )
{
	//TBD
	return eventArray;
}


dds_sort_ent_damage( eventArray )
{
	//TBD
	return eventArray;
}


// *************************************************
// DEBUG
// *************************************************
// ****************************
/*

level.dds.debug_hud_columns
	-hud element
	-column titles: contain the information we want to display

level.dds.debug.hud_categories[]
level.dds.debug.hud_categories_axis[]
	-hud elements
	-per category

level.dds.debug.hud_stats[][]?
	-hud element
	-hud stats, total count, processed count, percentage

level.dds.debug_stat_types[]
	-array of different stats to track
		cur_active_events				// current active events
		total_notify_count				// total count of notifies
		processed_count					// total count of notifies processed
		no_one_to_talk_count			// count of processed notifies that didn't play because there was no one to say it
		probability_skipped				// number of notifies that were skipped because of probability

level.dds.debug.active_event_stats[]
level.dds.debug.active_event_stats_axis[]
	-2d array of all active events (copy of level.dds.active_events [category_name][event])

*/
//****************************
/#
debug_destroy_hud_elem()
{
	if( GetDvarint( "dds_debugActiveEvents" ) != 1 )
	{
		// hud categories
		if( IsDefined( level.dds.debug.hud_categories ) )
		{
			for( i = 0; i < level.dds.debug.hud_categories.size; i++ )
			{
				if( IsDefined( level.dds.debug.hud_categories ) && IsDefined( level.dds.debug.hud_categories[i] ) 
					&& IsDefined( level.dds.debug.hud_stats ) && IsDefined( level.dds.debug.hud_stats[i] ) )
				{
					for( j = 0; j < level.dds.debug.hud_stats[i].size; j++ )
					{
						if( IsDefined( level.dds.debug.hud_stats ) && IsDefined(level.dds.debug.hud_stats[i][j] ) )
						{
							level.dds.debug.hud_stats[i][j] Destroy();
						}
					}
					level.dds.debug.hud_categories[i] Destroy();
				}
			}
			level.dds.debug.hud_categories = undefined;
		}

		// hud columns
		if( IsDefined( level.dds.debug_hud_columns ) )
		{
			for( i = 0; i < level.dds.debug_hud_columns.size; i++ )
			{
				if( IsDefined( level.dds.debug_hud_columns ) && IsDefined( level.dds.debug_hud_columns[i] ) )
				{
					level.dds.debug_hud_columns[i] Destroy();
				}
			}
			level.dds.debug_hud_columns = undefined;
		}

		// hud player name
		if( IsDefined( level.dds.debug.hud_player_name ) )
		{
			level.dds.debug.hud_player_name Destroy();
			level.dds.debug.hud_player_name = undefined;
		}
		// hud current event override
		if( IsDefined( level.dds.debug.hud_event_override ) )
		{
			level.dds.debug.hud_event_override Destroy();
			level.dds.debug.hud_event_override = undefined;
		}
		// hud current event override probability
		if( IsDefined( level.dds.debug.hud_event_override_probability ) )
		{
			level.dds.debug.hud_event_override_probability Destroy();
			level.dds.debug.hud_event_override_probability = undefined;
		}
	}
}


dds_debug()
{
	level.dds.debug = spawnstruct();

	level.dds.debug.active_event_stats = [];
	level.dds.debug.active_event_stats_axis = [];
	level.dds.debug.stat_types = array( "A. Events: ", "T. Notifies: ", "Processed: ", "Time1: ", "Cat. T.O.: ", "Backoff T.O.: " );

	for( i = 0; i < level.dds.categories.size; i++ )
	{
		//debug.active_event_stats
		level.dds.debug.active_event_stats[level.dds.categories[i].name] = spawnstruct();
		level.dds.debug.active_event_stats[level.dds.categories[i].name].cur_active_events = 0;
		level.dds.debug.active_event_stats[level.dds.categories[i].name].total_notify_count = 0;
		level.dds.debug.active_event_stats[level.dds.categories[i].name].processed_count = 0;
		level.dds.debug.active_event_stats[level.dds.categories[i].name].no_one_to_talk_count = 0;
		level.dds.debug.active_event_stats[level.dds.categories[i].name].probability_skipped = 0;
		level.dds.debug.active_event_stats[level.dds.categories[i].name].time_since_last_timeout = 0;
		level.dds.debug.active_event_stats[level.dds.categories[i].name].category_timeout = 0;
		level.dds.debug.active_event_stats[level.dds.categories[i].name].backoff_timeout = 0;
	}
	for( i = 0; i < level.dds.categories_axis.size; i++ )
	{
		//debug.active_event_stats
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name] = spawnstruct();
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].cur_active_events = 0;
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].total_notify_count = 0;
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].processed_count = 0;
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].no_one_to_talk_count = 0;
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].probability_skipped = 0;
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].time_since_last_timeout = 0;
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].category_timeout = 0;
		level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].backoff_timeout = 0;
	}

	while ( 1 )
	{
		if( GetDvarint( "dds_debugActiveEvents" ) != 1 )
		{
			wait( 1 );
			debug_destroy_hud_elem();
			continue;
		}

		for( i = 0; i < level.dds.categories.size; i++ )
		{
			level.dds.debug.active_event_stats[level.dds.categories[i].name].cur_active_events = level.dds.active_events[level.dds.categories[i].name].size;
		}
		for( i = 0; i < level.dds.categories_axis.size; i++ )
		{
			level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].cur_active_events = level.dds.active_events_axis[level.dds.categories_axis[i].name].size;
		}

		debug_hud_update();
		wait( level.dds.heartbeat );
	}
}


debug_update_timeouts( category_name, timeout, last_timeout, isAllies )
{
	if( isAllies )
	{
		if( level.dds.debug.active_event_stats[category_name].category_timeout > 0 )
			level.dds.debug.active_event_stats[category_name].category_timeout -= level.dds.heartbeat;

		if( level.dds.debug.active_event_stats[category_name].backoff_timeout > 0 )
			level.dds.debug.active_event_stats[category_name].backoff_timeout -= level.dds.heartbeat;
	}
	else
	{
		if( level.dds.debug.active_event_stats_axis[category_name].category_timeout > 0 )
			level.dds.debug.active_event_stats_axis[category_name].category_timeout -= level.dds.heartbeat;

		if( level.dds.debug.active_event_stats_axis[category_name].backoff_timeout > 0 )
			level.dds.debug.active_event_stats_axis[category_name].backoff_timeout -= level.dds.heartbeat;
	}
}


debug_reset_timeouts( category_name, timeout, last_timeout, last_time, isAllies )
{
	if( isAllies )
	{
		//time elapsed since last time a line from this category was played
		// gettime() - last_time
		level.dds.debug.active_event_stats[category_name].time_since_last_timeout = last_time;
		
		//countdown of the time left before the category can play again
		level.dds.debug.active_event_stats[category_name].category_timeout = timeout;

		//countdown before the threshold expires
		level.dds.debug.active_event_stats[category_name].backoff_timeout = timeout*1.5;//last_timeout * 1.5;
	}
	else
	{
		//time elapsed since last time a line from this category was played
		// gettime() - last_time
		level.dds.debug.active_event_stats_axis[category_name].time_since_last_timeout = last_time;
		
		//countdown of the time left before the category can play again
		level.dds.debug.active_event_stats_axis[category_name].category_timeout = timeout;

		//countdown before the threshold expires
		level.dds.debug.active_event_stats_axis[category_name].backoff_timeout = timeout*1.5;//last_timeout * 1.5;
	}
}


debug_hud_update()
{
	if( GetDvarint( "dds_debugActiveEvents" ) != 0 )
	{
		if( !IsDefined( level.dds.debug_hud_columns ) )
		{
			level.dds.debug_hud_columns = [];
			for( i = 0; i < level.dds.debug.stat_types.size; i++ )
			{
				level.dds.debug_hud_columns[i] = NewDebugHudElem();
				level.dds.debug_hud_columns[i].alignX = "left";
				level.dds.debug_hud_columns[i].x = ( (i + 1) * 85 ) - 50;
				level.dds.debug_hud_columns[i].y = 20;
				level.dds.debug_hud_columns[i].color = (0.1,0.1,.7);
				level.dds.debug_hud_columns[i] SetText( level.dds.debug.stat_types[i] );
			}
		}

		if( !IsDefined( level.dds.debug.hud_categories ) )
		{
			level.dds.debug.hud_categories = [];
			for( i = 0; i < level.dds.categories.size; i++ )
			{
				level.dds.debug.hud_categories[i] = NewDebugHudElem();
				level.dds.debug.hud_categories[i].alignX = "left";
				level.dds.debug.hud_categories[i].x = -70;
				level.dds.debug.hud_categories[i].y = 15 + (i + 1) * 15;
				level.dds.debug.hud_categories[i].color = (.7,0.1,0.1);
				level.dds.debug.hud_categories[i] SetText( level.dds.categories[i].name + ": " );
			}
		}

		if( !IsDefined( level.dds.debug.hud_stats ) )
		{
			level.dds.debug.hud_stats = [];
		}
		for( i = 0; i < level.dds.categories.size; i++ )
		{
			if( !IsDefined( level.dds.debug.hud_stats[i] ) )
			{
				level.dds.debug.hud_stats[i] = [];
			}
			for( j = 0; j < level.dds.debug.stat_types.size; j++ )
			{
				if( !IsDefined( level.dds.debug.hud_stats[i][j] ) )
				{
					level.dds.debug.hud_stats[i][j] = NewDebugHudElem();
					level.dds.debug.hud_stats[i][j].alignX = "left";
					level.dds.debug.hud_stats[i][j].x = ( (j + 1) * 85 ) - 50;
					level.dds.debug.hud_stats[i][j].y = 15 + (i + 1) * 15;
				}
			}
			//level.dds.debug.stat_types = array( "Active Events: ", "Total Notify Count: ", "Processed Count: " );//, "Percent: ");
			level.dds.debug.hud_stats[i][0] SetValue( level.dds.debug.active_event_stats[level.dds.categories[i].name].cur_active_events );
			level.dds.debug.hud_stats[i][1] SetValue( level.dds.debug.active_event_stats[level.dds.categories[i].name].total_notify_count );
			level.dds.debug.hud_stats[i][2] SetValue( level.dds.debug.active_event_stats[level.dds.categories[i].name].processed_count );
			level.dds.debug.hud_stats[i][3] SetValue( GetTime() - level.dds.debug.active_event_stats[level.dds.categories[i].name].time_since_last_timeout );
			level.dds.debug.hud_stats[i][4] SetValue( level.dds.debug.active_event_stats[level.dds.categories[i].name].category_timeout );
			level.dds.debug.hud_stats[i][5] SetValue( level.dds.debug.active_event_stats[level.dds.categories[i].name].backoff_timeout );
			//level.dds.debug.hud_stats[i][3] SetValue( level.dds.debug.active_event_stats[level.dds.categories[i].name].probability_skipped );
			//level.dds.debug.hud_stats[i][4] SetValue( level.dds.debug.active_event_stats[level.dds.categories[i].name].no_one_to_talk_count );
		}

		// player name
		// move somewhere else on screen or something since it blocks other info on screen
		/*
		if( !IsDefined( level.dds.debug.hud_player_name ) )
		{
			level.dds.debug.hud_player_name = NewDebugHudElem();
			level.dds.debug.hud_player_name.alignX = "left";
			level.dds.debug.hud_player_name.x = -75;
			level.dds.debug.hud_player_name.y = 210;
			level.dds.debug.hud_player_name.color = (1,1,0);
		}
		level.dds.debug.hud_player_name SetText( "Player Name: " + level.dds.player_character_name );

		// current event override
		if( !IsDefined( level.dds.debug.hud_event_override ) )
		{
			level.dds.debug.hud_event_override = NewDebugHudElem();
			level.dds.debug.hud_event_override.alignX = "left";
			level.dds.debug.hud_event_override.x = -75;
			level.dds.debug.hud_event_override.y = 225;
			level.dds.debug.hud_event_override.color = (1,1,0);
		}
		if( !IsDefined( level.dds.event_override_name ) )
			level.dds.debug.hud_event_override SetText( "Event Override: none" );
		else
			level.dds.debug.hud_event_override SetText( "Event Override: " + level.dds.event_override_name );

		// current event override probability
		if( !IsDefined( level.dds.debug.hud_event_override_probability ) )
		{
			level.dds.debug.hud_event_override_probability = NewDebugHudElem();
			level.dds.debug.hud_event_override_probability.alignX = "left";
			level.dds.debug.hud_event_override_probability.x = -75;
			level.dds.debug.hud_event_override_probability.y = 240;
			level.dds.debug.hud_event_override_probability.color = (1,1,0);
		}
		level.dds.debug.hud_event_override_probability SetText( "Event Override Prob: " + level.dds.event_override_probability );
		*/
	}
}


debug_active_event_stat( category_name, stat, isAllies )
{
	if( isAllies )
	{
		if( !IsDefined( level.dds.debug.active_event_stats[category_name] ) )
			return;

		switch( stat )
		{
			case "total_notify_count":
				level.dds.debug.active_event_stats[category_name].total_notify_count++;
				break;
			case "processed_count":
				level.dds.debug.active_event_stats[category_name].processed_count++;
				break;
			case "no_one_to_talk_count":
				level.dds.debug.active_event_stats[category_name].no_one_to_talk_count++;
				break;
			case "probability_skipped":
				level.dds.debug.active_event_stats[category_name].probability_skipped++;
				break;
		}
	}
	else
	{
		if( !IsDefined( level.dds.debug.active_event_stats_axis[category_name] ) )
			return;

		switch( stat )
		{
			case "total_notify_count":
				level.dds.debug.active_event_stats_axis[category_name].total_notify_count++;
				break;
			case "processed_count":
				level.dds.debug.active_event_stats_axis[category_name].processed_count++;
				break;
			case "no_one_to_talk_count":
				level.dds.debug.active_event_stats_axis[category_name].no_one_to_talk_count++;
				break;
			case "probability_skipped":
				level.dds.debug.active_event_stats_axis[category_name].probability_skipped++;
				break;
		}
	}
}


debug_sphere_draw_type( event_type, category_name, event, speaker ) //notify, process,...
{
	if( !IsDefined( event ) )
		return;

	draw_info = spawnstruct();
	draw_info.event_type = event_type;
	draw_info.ent_number = event.ent_number;
	draw_info.ent_origin = event.ent_origin;
	draw_info.category_name = category_name;
	draw_info.color = level.color_debug["white"];

	if( IsDefined( event.category_response_name ) && ( event.category_response_name == category_name ) )
	{
		//draw_info.ent_number = event.talker_number;
		draw_info.ent_origin = event.talker_origin;
	}

	switch( event_type )
	{
		case "notify":
			draw_info.color = level.color_debug["cyan"];
			break;
		case "process":
			draw_info.color = level.color_debug["orange"];
			break;
		case "speaker": //for the ent/AI who says the line
			draw_info.color = level.color_debug["green"];
			if( IsDefined( speaker ) )
			{
				draw_info.speaker_ent_number = speaker getentitynumber();
				draw_info.speaker_ent_origin = speaker.origin;
			}
			if( IsDefined( event.category_response_name ) )
			{
				draw_info.color = level.color_debug["magenta"];
				//draw_info.ent_number = event.talker_number;
				draw_info.ent_origin = event.talker_origin;
			}
			break;
		default:
			iprintlnbold( "no known type of event notify: " + event_type + ". setting color to white\n");
			break;
		
	}

	//debug_draw_info( draw_info );
	draw_info debug_draw_info();
}


debug_draw_info() //self == draw_info
{
	if( IsDefined( self.ent_number ) )
		ent_print_text = "ent triggered: " + self.ent_number;
	else
		ent_print_text = "ent triggered: unknown";

	display_ent_origin = self.ent_origin;

	if( IsDefined( self.speaker_ent_number ) && IsDefined( self.speaker_ent_origin ) )
	{
		ent_print_text = "ent speaker: " + self.speaker_ent_number;
		display_ent_origin = self.speaker_ent_origin;
	}

	//sphere/debugstar
	draw_3d_sphere = GetDvarIntDefault( "dds_drawDebug", 0 );
	if( IsDefined( draw_3d_sphere ) && ( draw_3d_sphere == 1 ) )
	{
		//sphere( ( display_ent_origin + (0,0,70) ) );//, radius, (1,1,1), false, true, 1*100 );
		debugstar( ( display_ent_origin + (0,0,70) ), int( 1*100 ), self.color );

		if( IsDefined( self.speaker_ent_number ) )
		{
			//draw line from speaker to trigger_ent
			//"Name: Line( <start>, <end>, <color>, <alpha>, <depthTest>, <duration> )"
			line( self.ent_origin + (0,0,70), self.speaker_ent_origin + (0,0,70), self.color, 1, 1, int( 1*100 ) );
		}
	}

	//text
	draw_3d_text = GetDvarIntDefault( "dds_drawDebugText", 0 );
	if( IsDefined( draw_3d_text ) && ( draw_3d_text == 1 ) )
	{
		//print3d( origin, text, RGB, alpha, scale, duration )
		print3d( ( display_ent_origin + ( 0, 0, 70 ) ), "event: " + self.event_type, self.color, 1, .7, int( 1*100 ) );
		print3d( ( display_ent_origin + ( 0, 0, 80 ) ), ent_print_text, self.color , 1, .7, int( 1*100 ) );
		print3d( ( display_ent_origin + ( 0, 0, 90 ) ), "category: " + self.category_name, self.color, 1, .7, int( 1*100 ) );
		//print3d( ( event.ent_origin + ( 0, 0, 85 ) ), "ent attacker" + event.ent_attacker (0, 1, 0), 1, 1.25 ); 
	}
}


dds_debug_player_health() //self == player
{
	self endon( "death" );
	self endon( "disconnect" );

	player_health_hud = undefined;
	if( !IsDefined( player_health_hud ) )
	{
		player_health_hud = NewDebugHudElem();
		player_health_hud.alignX = "left";
		player_health_hud.x = -75;
		player_health_hud.y = 255;
		player_health_hud.color = (0,0,1);
	}

	while( 1 )
	{
		player_health_hud SetValue( self.health );

		wait( 0.5 );
	}
}


debug_print_dialogue( soundAlias ) //self == talker 
{
	if( !is_dds_enabled() )
		return;

	self endon( "death" );
	self endon( "disconnect" );

	self notify( "stop_dds_dialogue_print" );
	self endon( "stop_dds_dialogue_print" );

	size = soundAlias.size;

	time = GetTime() + 3000;
	if( size > 25 )
	{
		time = GetTime() + ( size * 0.1 * 1000 );
	}

	while( GetTime() < time && IsAlive( self ) )
	{
		Print3d( self.origin + (0, 0, 72), soundAlias );
		wait( 0.05 );
	}

}
#/


// *************************************************
// PUBLIC FUNCTIONS (prob be moved to utility script?)
// *************************************************
dds_set_event_override( event_name )
{
	level.dds.event_override_name = event_name;
}


dds_clear_event_override()
{
	level.dds.event_override_name = undefined;
}


dds_set_event_override_probability( probability_value )
{
	if( probability_value < 0 || probability_value > 1 )
	{
		/#PrintLn( probability_value + " is invalid event override probability. value must be between 0 and 1. resetting to default." );#/
		dds_reset_event_override_probability();
	}
	else
	{
		level.dds.event_override_probability = probability_value;
	}
}


dds_reset_event_override_probability()
{
	level.dds.event_override_probability = .5;
}

